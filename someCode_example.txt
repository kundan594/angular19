 <img
      [src]="'assets/users/' + selectedUser.avatar"
      [alt]="selectedUser.name"
    />


    get imagePath() {
    return 'assets/users/' + this.selectedUser.avatar
  }


  <div>
  <button (click)="onSelectUser()">
    <img [src]="imagePath" [alt]="selectedUser.name" />
    <span>{{ selectedUser.name }}</span>
  </button>
</div>



with signal 

 selectedUser = signal(DUMMY_USERS[randomIndex]);
  imagePath = computed(() => 'assets/users/' + this.selectedUser().avatar)

  // get imagePath() {
  //   return 'assets/users/' + this.selectedUser.avatar
  // }

  onSelectUser() {
    const randomIndex = Math.floor(Math.random() * DUMMY_USERS.length);
    this.selectedUser.set(DUMMY_USERS[randomIndex]);
  }


  @Input() avatar!: string;
  @Input() name!: string;



  @Input({ required: true }) avatar!: string;
  @Input({ required: true }) name!: string;

  @Input() name?: string;


  @Input({ required: true }) user!: User;
  @Output() select = new EventEmitter();

  
// type User = {
//   id: string;
//   avatar: string;
//   name: string;
// }


interface User {
  id: string;
  avatar: string;
  name: string;
}

 @Input({ required: true }) user!: User;
  @Output() select = new EventEmitter();


  <main>
  <ul id="users">
    @for (user of users; track user.id) {
      <li>
        <app-user [user]="user" (select)="onSelectUser($event)" />
      </li>
    }
  </ul>

  @if (selectedUser) {
    <app-tasks [name]="selectedUser.name" />
  } @else {
    <p id="fallback">Select a user to see their tasks!</p>
  }


   get selectedUser() {
    return this.users.find((user) => user.id === this.selectedUserId);
  }

  <button [class.active]="selected" (click)="onSelectUser()">


  <div
  [class]="{
    status: true,
    'status-online': currentStatus === 'online',
    'status-offline': currentStatus === 'offline',
    'status-unknown': currentStatus === 'unknown'
  }" >




  In TypeScript, the statement:

declare var variable_name: type;

Copy

Insert

means you are telling the TypeScript compiler that a variable named variable_name exists somewhere (for example, it is provided by an external script or library), but you are not defining it in your code. You are only declaring its existence and (optionally) its type.

Why use declare var?
To let TypeScript know about global variables that are defined outside your TypeScript code (e.g., by a CDN script, legacy JS, or a browser API).
To avoid TypeScript errors about "cannot find name" for variables that are actually available at runtime.

Key Points
declare var does NOT create the variable or allocate memory for it.
It only tells TypeScript about its existence and type.
It is used for type checking and code completion, not for actual variable definition.



https://angular.dev/tools/libraries/creating-libraries 


ng new my-workspace --no-create-application
cd my-workspace
ng generate library my-lib

ng build my-lib --configuration development
ng test my-lib
ng lint my-lib



In Angular, EventType is related to the Angular Router’s navigation events. These events help you track the lifecycle of route changes. Here are all the main event types you’ll encounter:

Angular Router Event Types
NavigationStart

Fired when navigation starts.
Useful for showing loading indicators.
NavigationEnd

Fired when navigation ends successfully.
Useful for hiding loaders or tracking page views.
NavigationCancel

Fired when navigation is canceled (e.g., a guard returns false).
NavigationError

Fired when navigation fails due to an error.
RoutesRecognized

Fired when the router parses the URL and recognizes the route.
GuardsCheckStart

Fired when router starts running route guards.
GuardsCheckEnd

Fired when router finishes running route guards.
ResolveStart

Fired when router starts running route resolvers.
ResolveEnd

Fired when router finishes running route resolvers.
ChildActivationStart

Fired when a child route is about to be activated.
ChildActivationEnd

Fired when a child route has been activated.
ActivationStart

Fired when a route is about to be activated.
ActivationEnd

Fired when a route has been activated.
Example: Listening to Router Events
Summary:
These event types let you react to every stage of Angular’s navigation process, such as showing/hiding loaders, handling errors, or tracking route changes.




ets you use *ngIf, *ngFor, *ngSwitch, etc., without adding extra HTML elements to the DOM.

*Example: Using ngIf

<ng-container *ngIf="isLoggedIn">
  <p>Welcome, user!</p>
</ng-container>

Copy

Insert

No extra wrapper is added to the DOM.

2. Grouping Multiple Elements for a Directive
You can group multiple elements under a single structural directive.

*Example: Multiple elements with ngIf

<ng-container *ngIf="showDetails">
  <h2>Details</h2>
  <p>Here are more details...</p>
</ng-container>

Copy

Insert

3. Using *ngFor Without Extra DOM
Example:

<ng-container *ngFor="let item of items">
  <li>{{ item }}</li>
</ng-container>

Copy

Insert

No extra element is created for the loop.

4. Nesting Structural Directives
You cannot use two structural directives on the same element, but you can nest them with .

**Example: ngIf inside ngFor

<ul>
  <li *ngFor="let user of users">
    <ng-container *ngIf="user.active">
      {{ user.name }}
    </ng-container>
  </li>
</ul>

Copy

Insert

5. *ngSwitch with
Example:

<ng-container [ngSwitch]="status">
  <p *ngSwitchCase="'loading'">Loading...</p>
  <p *ngSwitchCase="'error'">Error!</p>
  <p *ngSwitchDefault>Ready</p>
</ng-container>

Copy

Insert

6. Template Reference Variables
You can use to define a template reference variable for a block of content.

Example:

<ng-container #myBlock>
  <p>This is a block of content.</p>
</ng-container>
<button (click)="doSomething(myBlock)">Click me</button>

Copy

Insert

7. Conditional Content Projection
In Angular content projection (ng-content), you can use to conditionally project content.

Example:

<!-- In parent component template -->
<app-card>
  <ng-container *ngIf="showHeader" ngProjectAs="header">
    <h1>Header</h1>
  </ng-container>
</app-card>

Copy

Insert

8. Dynamic Component Loading
You can use with ViewContainerRef to dynamically insert components.

Example (in TypeScript):

@ViewChild('container', { read: ViewContainerRef }) container: ViewContainerRef;

Copy

Insert

<ng-container #container></ng-container>

Copy

Insert

9. Using with Pipes
You can use to apply pipes to a block of content.

Example:

<ng-container *ngIf="user$ | async as user">
  <p>{{ user.name }}</p>
</ng-container>

Copy

Insert

10. Avoiding Unnecessary DOM Elements
Use to avoid adding unnecessary

or wrappers just for Angular logic.
Summary Table:

Structural directives*ngIf, *ngFor, *ngSwitchGrouping elementsMultiple elements under one directiveNesting directives*ngIf inside *ngForTemplate reference variables#ref for a blockContent projectionngProjectAs with *ngIfDynamic
 component loadingViewContainerRefUsing with pipesasync pipe with *ngIfAvoiding extra DOMNo extra or

{
...currentData,
...amountData
}
 vs 

{
...currentData,
amountData
}

what will diffetence explain with code

1. { ...currentData, ...amountData }
Effect:
This merges all properties from currentData and all properties from amountData into a new object.
Result:
If both objects have a property with the same name, the value from amountData will overwrite the value from currentData.
Example:

2. { ...currentData, amountData }
Effect:
This merges all properties from currentData and then adds a single property called amountData, whose value is the entire amountData object.
Result:
The resulting object will have all properties from currentData and one property named amountData (which is an object).
Example:

const currentData = { a: 1, b: 2 };
const amountData = { b: 3, c: 4 };

const result = { ...currentData, amountData };
// result: { a: 1, b: 2, amountData: { b: 3, c: 4 } }

Summary Table
Pattern	Resulting Object Structure
{ ...currentData, ...amountData }	All properties merged, keys from amountData overwrite currentData
{ ...currentData, amountData }	All properties from currentData + one property amountData (object)
In short:

...amountData spreads properties.
amountData adds a nested object property.